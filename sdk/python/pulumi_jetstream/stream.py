# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['StreamArgs', 'Stream']

@pulumi.input_type
class StreamArgs:
    def __init__(__self__, *,
                 ack: Optional[pulumi.Input[bool]] = None,
                 allow_direct: Optional[pulumi.Input[bool]] = None,
                 allow_rollup_hdrs: Optional[pulumi.Input[bool]] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 deny_delete: Optional[pulumi.Input[bool]] = None,
                 deny_purge: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 discard_new_per_subject: Optional[pulumi.Input[bool]] = None,
                 duplicate_window: Optional[pulumi.Input[int]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_consumers: Optional[pulumi.Input[int]] = None,
                 max_msg_size: Optional[pulumi.Input[int]] = None,
                 max_msgs: Optional[pulumi.Input[int]] = None,
                 max_msgs_per_subject: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mirror: Optional[pulumi.Input['StreamMirrorArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 placement_cluster: Optional[pulumi.Input[str]] = None,
                 placement_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 republish_destination: Optional[pulumi.Input[str]] = None,
                 republish_headers_only: Optional[pulumi.Input[bool]] = None,
                 republish_source: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]] = None,
                 storage: Optional[pulumi.Input[str]] = None,
                 subject_transform: Optional[pulumi.Input['StreamSubjectTransformArgs']] = None,
                 subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a Stream resource.
        :param pulumi.Input[bool] ack: If the Stream should support confirming receiving messages via acknowledgements
        :param pulumi.Input[bool] allow_direct: Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        :param pulumi.Input[bool] allow_rollup_hdrs: Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        :param pulumi.Input[str] compression: Optional compression algorithm used for the Stream
        :param pulumi.Input[bool] deny_delete: Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        :param pulumi.Input[bool] deny_purge: Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        :param pulumi.Input[str] description: Contains additional information about this stream
        :param pulumi.Input[str] discard: When a Stream reach it's limits either old messages are deleted or new ones are denied
        :param pulumi.Input[bool] discard_new_per_subject: When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        :param pulumi.Input[int] duplicate_window: The size of the duplicate tracking windows, duration specified in seconds
        :param pulumi.Input[int] max_age: The maximum oldest message that can be kept in the stream, duration specified in seconds
        :param pulumi.Input[int] max_bytes: The maximum size of all messages that can be kept in the stream
        :param pulumi.Input[int] max_consumers: Number of consumers this stream allows
        :param pulumi.Input[int] max_msg_size: The maximum individual message size that the stream will accept
        :param pulumi.Input[int] max_msgs: The maximum amount of messages that can be kept in the stream
        :param pulumi.Input[int] max_msgs_per_subject: The maximum amount of messages that can be kept in the stream on a per-subject basis
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Free form metadata about the stream
        :param pulumi.Input['StreamMirrorArgs'] mirror: Specifies a remote stream to mirror into this one
        :param pulumi.Input[str] name: The name of the source Stream
        :param pulumi.Input[str] placement_cluster: Place the stream in a specific cluster, influenced by placement_tags
        :param pulumi.Input[Sequence[pulumi.Input[str]]] placement_tags: Place the stream only on servers with these tags
        :param pulumi.Input[int] replicas: How many replicas of the data to keep in a clustered environment
        :param pulumi.Input[str] republish_destination: The destination to publish messages to
        :param pulumi.Input[bool] republish_headers_only: Republish only message headers, no bodies
        :param pulumi.Input[str] republish_source: Republish messages to republish_destination
        :param pulumi.Input[str] retention: The retention policy to apply over and above max*msgs, max*bytes and max_age
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]] sources: The subject transform source
        :param pulumi.Input[str] storage: The storage engine to use to back the stream
        :param pulumi.Input['StreamSubjectTransformArgs'] subject_transform: The subject filtering sources and associated destination transforms
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subjects: The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        if ack is not None:
            pulumi.set(__self__, "ack", ack)
        if allow_direct is not None:
            pulumi.set(__self__, "allow_direct", allow_direct)
        if allow_rollup_hdrs is not None:
            pulumi.set(__self__, "allow_rollup_hdrs", allow_rollup_hdrs)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if deny_delete is not None:
            pulumi.set(__self__, "deny_delete", deny_delete)
        if deny_purge is not None:
            pulumi.set(__self__, "deny_purge", deny_purge)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if discard_new_per_subject is not None:
            pulumi.set(__self__, "discard_new_per_subject", discard_new_per_subject)
        if duplicate_window is not None:
            pulumi.set(__self__, "duplicate_window", duplicate_window)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)
        if max_msg_size is not None:
            pulumi.set(__self__, "max_msg_size", max_msg_size)
        if max_msgs is not None:
            pulumi.set(__self__, "max_msgs", max_msgs)
        if max_msgs_per_subject is not None:
            pulumi.set(__self__, "max_msgs_per_subject", max_msgs_per_subject)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if mirror is not None:
            pulumi.set(__self__, "mirror", mirror)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if placement_cluster is not None:
            pulumi.set(__self__, "placement_cluster", placement_cluster)
        if placement_tags is not None:
            pulumi.set(__self__, "placement_tags", placement_tags)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if republish_destination is not None:
            pulumi.set(__self__, "republish_destination", republish_destination)
        if republish_headers_only is not None:
            pulumi.set(__self__, "republish_headers_only", republish_headers_only)
        if republish_source is not None:
            pulumi.set(__self__, "republish_source", republish_source)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if subject_transform is not None:
            pulumi.set(__self__, "subject_transform", subject_transform)
        if subjects is not None:
            pulumi.set(__self__, "subjects", subjects)

    @property
    @pulumi.getter
    def ack(self) -> Optional[pulumi.Input[bool]]:
        """
        If the Stream should support confirming receiving messages via acknowledgements
        """
        return pulumi.get(self, "ack")

    @ack.setter
    def ack(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ack", value)

    @property
    @pulumi.getter(name="allowDirect")
    def allow_direct(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        """
        return pulumi.get(self, "allow_direct")

    @allow_direct.setter
    def allow_direct(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_direct", value)

    @property
    @pulumi.getter(name="allowRollupHdrs")
    def allow_rollup_hdrs(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        """
        return pulumi.get(self, "allow_rollup_hdrs")

    @allow_rollup_hdrs.setter
    def allow_rollup_hdrs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rollup_hdrs", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        Optional compression algorithm used for the Stream
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="denyDelete")
    def deny_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        """
        return pulumi.get(self, "deny_delete")

    @deny_delete.setter
    def deny_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_delete", value)

    @property
    @pulumi.getter(name="denyPurge")
    def deny_purge(self) -> Optional[pulumi.Input[bool]]:
        """
        Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        """
        return pulumi.get(self, "deny_purge")

    @deny_purge.setter
    def deny_purge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_purge", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Contains additional information about this stream
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[str]]:
        """
        When a Stream reach it's limits either old messages are deleted or new ones are denied
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter(name="discardNewPerSubject")
    def discard_new_per_subject(self) -> Optional[pulumi.Input[bool]]:
        """
        When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        """
        return pulumi.get(self, "discard_new_per_subject")

    @discard_new_per_subject.setter
    def discard_new_per_subject(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard_new_per_subject", value)

    @property
    @pulumi.getter(name="duplicateWindow")
    def duplicate_window(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the duplicate tracking windows, duration specified in seconds
        """
        return pulumi.get(self, "duplicate_window")

    @duplicate_window.setter
    def duplicate_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duplicate_window", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum oldest message that can be kept in the stream, duration specified in seconds
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of all messages that can be kept in the stream
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consumers this stream allows
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_consumers", value)

    @property
    @pulumi.getter(name="maxMsgSize")
    def max_msg_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum individual message size that the stream will accept
        """
        return pulumi.get(self, "max_msg_size")

    @max_msg_size.setter
    def max_msg_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msg_size", value)

    @property
    @pulumi.getter(name="maxMsgs")
    def max_msgs(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of messages that can be kept in the stream
        """
        return pulumi.get(self, "max_msgs")

    @max_msgs.setter
    def max_msgs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msgs", value)

    @property
    @pulumi.getter(name="maxMsgsPerSubject")
    def max_msgs_per_subject(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of messages that can be kept in the stream on a per-subject basis
        """
        return pulumi.get(self, "max_msgs_per_subject")

    @max_msgs_per_subject.setter
    def max_msgs_per_subject(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msgs_per_subject", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Free form metadata about the stream
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def mirror(self) -> Optional[pulumi.Input['StreamMirrorArgs']]:
        """
        Specifies a remote stream to mirror into this one
        """
        return pulumi.get(self, "mirror")

    @mirror.setter
    def mirror(self, value: Optional[pulumi.Input['StreamMirrorArgs']]):
        pulumi.set(self, "mirror", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source Stream
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="placementCluster")
    def placement_cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Place the stream in a specific cluster, influenced by placement_tags
        """
        return pulumi.get(self, "placement_cluster")

    @placement_cluster.setter
    def placement_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_cluster", value)

    @property
    @pulumi.getter(name="placementTags")
    def placement_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Place the stream only on servers with these tags
        """
        return pulumi.get(self, "placement_tags")

    @placement_tags.setter
    def placement_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "placement_tags", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        How many replicas of the data to keep in a clustered environment
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="republishDestination")
    def republish_destination(self) -> Optional[pulumi.Input[str]]:
        """
        The destination to publish messages to
        """
        return pulumi.get(self, "republish_destination")

    @republish_destination.setter
    def republish_destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "republish_destination", value)

    @property
    @pulumi.getter(name="republishHeadersOnly")
    def republish_headers_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Republish only message headers, no bodies
        """
        return pulumi.get(self, "republish_headers_only")

    @republish_headers_only.setter
    def republish_headers_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "republish_headers_only", value)

    @property
    @pulumi.getter(name="republishSource")
    def republish_source(self) -> Optional[pulumi.Input[str]]:
        """
        Republish messages to republish_destination
        """
        return pulumi.get(self, "republish_source")

    @republish_source.setter
    def republish_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "republish_source", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[str]]:
        """
        The retention policy to apply over and above max*msgs, max*bytes and max_age
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]]:
        """
        The subject transform source
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        The storage engine to use to back the stream
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="subjectTransform")
    def subject_transform(self) -> Optional[pulumi.Input['StreamSubjectTransformArgs']]:
        """
        The subject filtering sources and associated destination transforms
        """
        return pulumi.get(self, "subject_transform")

    @subject_transform.setter
    def subject_transform(self, value: Optional[pulumi.Input['StreamSubjectTransformArgs']]):
        pulumi.set(self, "subject_transform", value)

    @property
    @pulumi.getter
    def subjects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        return pulumi.get(self, "subjects")

    @subjects.setter
    def subjects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subjects", value)


@pulumi.input_type
class _StreamState:
    def __init__(__self__, *,
                 ack: Optional[pulumi.Input[bool]] = None,
                 allow_direct: Optional[pulumi.Input[bool]] = None,
                 allow_rollup_hdrs: Optional[pulumi.Input[bool]] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 deny_delete: Optional[pulumi.Input[bool]] = None,
                 deny_purge: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 discard_new_per_subject: Optional[pulumi.Input[bool]] = None,
                 duplicate_window: Optional[pulumi.Input[int]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_consumers: Optional[pulumi.Input[int]] = None,
                 max_msg_size: Optional[pulumi.Input[int]] = None,
                 max_msgs: Optional[pulumi.Input[int]] = None,
                 max_msgs_per_subject: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mirror: Optional[pulumi.Input['StreamMirrorArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 placement_cluster: Optional[pulumi.Input[str]] = None,
                 placement_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 republish_destination: Optional[pulumi.Input[str]] = None,
                 republish_headers_only: Optional[pulumi.Input[bool]] = None,
                 republish_source: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]] = None,
                 storage: Optional[pulumi.Input[str]] = None,
                 subject_transform: Optional[pulumi.Input['StreamSubjectTransformArgs']] = None,
                 subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties used for looking up and filtering Stream resources.
        :param pulumi.Input[bool] ack: If the Stream should support confirming receiving messages via acknowledgements
        :param pulumi.Input[bool] allow_direct: Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        :param pulumi.Input[bool] allow_rollup_hdrs: Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        :param pulumi.Input[str] compression: Optional compression algorithm used for the Stream
        :param pulumi.Input[bool] deny_delete: Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        :param pulumi.Input[bool] deny_purge: Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        :param pulumi.Input[str] description: Contains additional information about this stream
        :param pulumi.Input[str] discard: When a Stream reach it's limits either old messages are deleted or new ones are denied
        :param pulumi.Input[bool] discard_new_per_subject: When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        :param pulumi.Input[int] duplicate_window: The size of the duplicate tracking windows, duration specified in seconds
        :param pulumi.Input[int] max_age: The maximum oldest message that can be kept in the stream, duration specified in seconds
        :param pulumi.Input[int] max_bytes: The maximum size of all messages that can be kept in the stream
        :param pulumi.Input[int] max_consumers: Number of consumers this stream allows
        :param pulumi.Input[int] max_msg_size: The maximum individual message size that the stream will accept
        :param pulumi.Input[int] max_msgs: The maximum amount of messages that can be kept in the stream
        :param pulumi.Input[int] max_msgs_per_subject: The maximum amount of messages that can be kept in the stream on a per-subject basis
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Free form metadata about the stream
        :param pulumi.Input['StreamMirrorArgs'] mirror: Specifies a remote stream to mirror into this one
        :param pulumi.Input[str] name: The name of the source Stream
        :param pulumi.Input[str] placement_cluster: Place the stream in a specific cluster, influenced by placement_tags
        :param pulumi.Input[Sequence[pulumi.Input[str]]] placement_tags: Place the stream only on servers with these tags
        :param pulumi.Input[int] replicas: How many replicas of the data to keep in a clustered environment
        :param pulumi.Input[str] republish_destination: The destination to publish messages to
        :param pulumi.Input[bool] republish_headers_only: Republish only message headers, no bodies
        :param pulumi.Input[str] republish_source: Republish messages to republish_destination
        :param pulumi.Input[str] retention: The retention policy to apply over and above max*msgs, max*bytes and max_age
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]] sources: The subject transform source
        :param pulumi.Input[str] storage: The storage engine to use to back the stream
        :param pulumi.Input['StreamSubjectTransformArgs'] subject_transform: The subject filtering sources and associated destination transforms
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subjects: The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        if ack is not None:
            pulumi.set(__self__, "ack", ack)
        if allow_direct is not None:
            pulumi.set(__self__, "allow_direct", allow_direct)
        if allow_rollup_hdrs is not None:
            pulumi.set(__self__, "allow_rollup_hdrs", allow_rollup_hdrs)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if deny_delete is not None:
            pulumi.set(__self__, "deny_delete", deny_delete)
        if deny_purge is not None:
            pulumi.set(__self__, "deny_purge", deny_purge)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if discard is not None:
            pulumi.set(__self__, "discard", discard)
        if discard_new_per_subject is not None:
            pulumi.set(__self__, "discard_new_per_subject", discard_new_per_subject)
        if duplicate_window is not None:
            pulumi.set(__self__, "duplicate_window", duplicate_window)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)
        if max_msg_size is not None:
            pulumi.set(__self__, "max_msg_size", max_msg_size)
        if max_msgs is not None:
            pulumi.set(__self__, "max_msgs", max_msgs)
        if max_msgs_per_subject is not None:
            pulumi.set(__self__, "max_msgs_per_subject", max_msgs_per_subject)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if mirror is not None:
            pulumi.set(__self__, "mirror", mirror)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if placement_cluster is not None:
            pulumi.set(__self__, "placement_cluster", placement_cluster)
        if placement_tags is not None:
            pulumi.set(__self__, "placement_tags", placement_tags)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if republish_destination is not None:
            pulumi.set(__self__, "republish_destination", republish_destination)
        if republish_headers_only is not None:
            pulumi.set(__self__, "republish_headers_only", republish_headers_only)
        if republish_source is not None:
            pulumi.set(__self__, "republish_source", republish_source)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if subject_transform is not None:
            pulumi.set(__self__, "subject_transform", subject_transform)
        if subjects is not None:
            pulumi.set(__self__, "subjects", subjects)

    @property
    @pulumi.getter
    def ack(self) -> Optional[pulumi.Input[bool]]:
        """
        If the Stream should support confirming receiving messages via acknowledgements
        """
        return pulumi.get(self, "ack")

    @ack.setter
    def ack(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ack", value)

    @property
    @pulumi.getter(name="allowDirect")
    def allow_direct(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        """
        return pulumi.get(self, "allow_direct")

    @allow_direct.setter
    def allow_direct(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_direct", value)

    @property
    @pulumi.getter(name="allowRollupHdrs")
    def allow_rollup_hdrs(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        """
        return pulumi.get(self, "allow_rollup_hdrs")

    @allow_rollup_hdrs.setter
    def allow_rollup_hdrs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_rollup_hdrs", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        Optional compression algorithm used for the Stream
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="denyDelete")
    def deny_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        """
        return pulumi.get(self, "deny_delete")

    @deny_delete.setter
    def deny_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_delete", value)

    @property
    @pulumi.getter(name="denyPurge")
    def deny_purge(self) -> Optional[pulumi.Input[bool]]:
        """
        Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        """
        return pulumi.get(self, "deny_purge")

    @deny_purge.setter
    def deny_purge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deny_purge", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Contains additional information about this stream
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def discard(self) -> Optional[pulumi.Input[str]]:
        """
        When a Stream reach it's limits either old messages are deleted or new ones are denied
        """
        return pulumi.get(self, "discard")

    @discard.setter
    def discard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "discard", value)

    @property
    @pulumi.getter(name="discardNewPerSubject")
    def discard_new_per_subject(self) -> Optional[pulumi.Input[bool]]:
        """
        When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        """
        return pulumi.get(self, "discard_new_per_subject")

    @discard_new_per_subject.setter
    def discard_new_per_subject(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "discard_new_per_subject", value)

    @property
    @pulumi.getter(name="duplicateWindow")
    def duplicate_window(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the duplicate tracking windows, duration specified in seconds
        """
        return pulumi.get(self, "duplicate_window")

    @duplicate_window.setter
    def duplicate_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duplicate_window", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum oldest message that can be kept in the stream, duration specified in seconds
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of all messages that can be kept in the stream
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consumers this stream allows
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_consumers", value)

    @property
    @pulumi.getter(name="maxMsgSize")
    def max_msg_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum individual message size that the stream will accept
        """
        return pulumi.get(self, "max_msg_size")

    @max_msg_size.setter
    def max_msg_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msg_size", value)

    @property
    @pulumi.getter(name="maxMsgs")
    def max_msgs(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of messages that can be kept in the stream
        """
        return pulumi.get(self, "max_msgs")

    @max_msgs.setter
    def max_msgs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msgs", value)

    @property
    @pulumi.getter(name="maxMsgsPerSubject")
    def max_msgs_per_subject(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of messages that can be kept in the stream on a per-subject basis
        """
        return pulumi.get(self, "max_msgs_per_subject")

    @max_msgs_per_subject.setter
    def max_msgs_per_subject(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_msgs_per_subject", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Free form metadata about the stream
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def mirror(self) -> Optional[pulumi.Input['StreamMirrorArgs']]:
        """
        Specifies a remote stream to mirror into this one
        """
        return pulumi.get(self, "mirror")

    @mirror.setter
    def mirror(self, value: Optional[pulumi.Input['StreamMirrorArgs']]):
        pulumi.set(self, "mirror", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source Stream
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="placementCluster")
    def placement_cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Place the stream in a specific cluster, influenced by placement_tags
        """
        return pulumi.get(self, "placement_cluster")

    @placement_cluster.setter
    def placement_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_cluster", value)

    @property
    @pulumi.getter(name="placementTags")
    def placement_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Place the stream only on servers with these tags
        """
        return pulumi.get(self, "placement_tags")

    @placement_tags.setter
    def placement_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "placement_tags", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        How many replicas of the data to keep in a clustered environment
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="republishDestination")
    def republish_destination(self) -> Optional[pulumi.Input[str]]:
        """
        The destination to publish messages to
        """
        return pulumi.get(self, "republish_destination")

    @republish_destination.setter
    def republish_destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "republish_destination", value)

    @property
    @pulumi.getter(name="republishHeadersOnly")
    def republish_headers_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Republish only message headers, no bodies
        """
        return pulumi.get(self, "republish_headers_only")

    @republish_headers_only.setter
    def republish_headers_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "republish_headers_only", value)

    @property
    @pulumi.getter(name="republishSource")
    def republish_source(self) -> Optional[pulumi.Input[str]]:
        """
        Republish messages to republish_destination
        """
        return pulumi.get(self, "republish_source")

    @republish_source.setter
    def republish_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "republish_source", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[str]]:
        """
        The retention policy to apply over and above max*msgs, max*bytes and max_age
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]]:
        """
        The subject transform source
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[str]]:
        """
        The storage engine to use to back the stream
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="subjectTransform")
    def subject_transform(self) -> Optional[pulumi.Input['StreamSubjectTransformArgs']]:
        """
        The subject filtering sources and associated destination transforms
        """
        return pulumi.get(self, "subject_transform")

    @subject_transform.setter
    def subject_transform(self, value: Optional[pulumi.Input['StreamSubjectTransformArgs']]):
        pulumi.set(self, "subject_transform", value)

    @property
    @pulumi.getter
    def subjects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        return pulumi.get(self, "subjects")

    @subjects.setter
    def subjects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subjects", value)


class Stream(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ack: Optional[pulumi.Input[bool]] = None,
                 allow_direct: Optional[pulumi.Input[bool]] = None,
                 allow_rollup_hdrs: Optional[pulumi.Input[bool]] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 deny_delete: Optional[pulumi.Input[bool]] = None,
                 deny_purge: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 discard_new_per_subject: Optional[pulumi.Input[bool]] = None,
                 duplicate_window: Optional[pulumi.Input[int]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_consumers: Optional[pulumi.Input[int]] = None,
                 max_msg_size: Optional[pulumi.Input[int]] = None,
                 max_msgs: Optional[pulumi.Input[int]] = None,
                 max_msgs_per_subject: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mirror: Optional[pulumi.Input[pulumi.InputType['StreamMirrorArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 placement_cluster: Optional[pulumi.Input[str]] = None,
                 placement_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 republish_destination: Optional[pulumi.Input[str]] = None,
                 republish_headers_only: Optional[pulumi.Input[bool]] = None,
                 republish_source: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StreamSourceArgs']]]]] = None,
                 storage: Optional[pulumi.Input[str]] = None,
                 subject_transform: Optional[pulumi.Input[pulumi.InputType['StreamSubjectTransformArgs']]] = None,
                 subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        Create a Stream resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] ack: If the Stream should support confirming receiving messages via acknowledgements
        :param pulumi.Input[bool] allow_direct: Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        :param pulumi.Input[bool] allow_rollup_hdrs: Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        :param pulumi.Input[str] compression: Optional compression algorithm used for the Stream
        :param pulumi.Input[bool] deny_delete: Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        :param pulumi.Input[bool] deny_purge: Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        :param pulumi.Input[str] description: Contains additional information about this stream
        :param pulumi.Input[str] discard: When a Stream reach it's limits either old messages are deleted or new ones are denied
        :param pulumi.Input[bool] discard_new_per_subject: When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        :param pulumi.Input[int] duplicate_window: The size of the duplicate tracking windows, duration specified in seconds
        :param pulumi.Input[int] max_age: The maximum oldest message that can be kept in the stream, duration specified in seconds
        :param pulumi.Input[int] max_bytes: The maximum size of all messages that can be kept in the stream
        :param pulumi.Input[int] max_consumers: Number of consumers this stream allows
        :param pulumi.Input[int] max_msg_size: The maximum individual message size that the stream will accept
        :param pulumi.Input[int] max_msgs: The maximum amount of messages that can be kept in the stream
        :param pulumi.Input[int] max_msgs_per_subject: The maximum amount of messages that can be kept in the stream on a per-subject basis
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Free form metadata about the stream
        :param pulumi.Input[pulumi.InputType['StreamMirrorArgs']] mirror: Specifies a remote stream to mirror into this one
        :param pulumi.Input[str] name: The name of the source Stream
        :param pulumi.Input[str] placement_cluster: Place the stream in a specific cluster, influenced by placement_tags
        :param pulumi.Input[Sequence[pulumi.Input[str]]] placement_tags: Place the stream only on servers with these tags
        :param pulumi.Input[int] replicas: How many replicas of the data to keep in a clustered environment
        :param pulumi.Input[str] republish_destination: The destination to publish messages to
        :param pulumi.Input[bool] republish_headers_only: Republish only message headers, no bodies
        :param pulumi.Input[str] republish_source: Republish messages to republish_destination
        :param pulumi.Input[str] retention: The retention policy to apply over and above max*msgs, max*bytes and max_age
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StreamSourceArgs']]]] sources: The subject transform source
        :param pulumi.Input[str] storage: The storage engine to use to back the stream
        :param pulumi.Input[pulumi.InputType['StreamSubjectTransformArgs']] subject_transform: The subject filtering sources and associated destination transforms
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subjects: The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[StreamArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a Stream resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param StreamArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(StreamArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ack: Optional[pulumi.Input[bool]] = None,
                 allow_direct: Optional[pulumi.Input[bool]] = None,
                 allow_rollup_hdrs: Optional[pulumi.Input[bool]] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 deny_delete: Optional[pulumi.Input[bool]] = None,
                 deny_purge: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 discard: Optional[pulumi.Input[str]] = None,
                 discard_new_per_subject: Optional[pulumi.Input[bool]] = None,
                 duplicate_window: Optional[pulumi.Input[int]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_bytes: Optional[pulumi.Input[int]] = None,
                 max_consumers: Optional[pulumi.Input[int]] = None,
                 max_msg_size: Optional[pulumi.Input[int]] = None,
                 max_msgs: Optional[pulumi.Input[int]] = None,
                 max_msgs_per_subject: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 mirror: Optional[pulumi.Input[pulumi.InputType['StreamMirrorArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 placement_cluster: Optional[pulumi.Input[str]] = None,
                 placement_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 republish_destination: Optional[pulumi.Input[str]] = None,
                 republish_headers_only: Optional[pulumi.Input[bool]] = None,
                 republish_source: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StreamSourceArgs']]]]] = None,
                 storage: Optional[pulumi.Input[str]] = None,
                 subject_transform: Optional[pulumi.Input[pulumi.InputType['StreamSubjectTransformArgs']]] = None,
                 subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = StreamArgs.__new__(StreamArgs)

            __props__.__dict__["ack"] = ack
            __props__.__dict__["allow_direct"] = allow_direct
            __props__.__dict__["allow_rollup_hdrs"] = allow_rollup_hdrs
            __props__.__dict__["compression"] = compression
            __props__.__dict__["deny_delete"] = deny_delete
            __props__.__dict__["deny_purge"] = deny_purge
            __props__.__dict__["description"] = description
            __props__.__dict__["discard"] = discard
            __props__.__dict__["discard_new_per_subject"] = discard_new_per_subject
            __props__.__dict__["duplicate_window"] = duplicate_window
            __props__.__dict__["max_age"] = max_age
            __props__.__dict__["max_bytes"] = max_bytes
            __props__.__dict__["max_consumers"] = max_consumers
            __props__.__dict__["max_msg_size"] = max_msg_size
            __props__.__dict__["max_msgs"] = max_msgs
            __props__.__dict__["max_msgs_per_subject"] = max_msgs_per_subject
            __props__.__dict__["metadata"] = metadata
            __props__.__dict__["mirror"] = mirror
            __props__.__dict__["name"] = name
            __props__.__dict__["placement_cluster"] = placement_cluster
            __props__.__dict__["placement_tags"] = placement_tags
            __props__.__dict__["replicas"] = replicas
            __props__.__dict__["republish_destination"] = republish_destination
            __props__.__dict__["republish_headers_only"] = republish_headers_only
            __props__.__dict__["republish_source"] = republish_source
            __props__.__dict__["retention"] = retention
            __props__.__dict__["sources"] = sources
            __props__.__dict__["storage"] = storage
            __props__.__dict__["subject_transform"] = subject_transform
            __props__.__dict__["subjects"] = subjects
        super(Stream, __self__).__init__(
            'jetstream:index/stream:Stream',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ack: Optional[pulumi.Input[bool]] = None,
            allow_direct: Optional[pulumi.Input[bool]] = None,
            allow_rollup_hdrs: Optional[pulumi.Input[bool]] = None,
            compression: Optional[pulumi.Input[str]] = None,
            deny_delete: Optional[pulumi.Input[bool]] = None,
            deny_purge: Optional[pulumi.Input[bool]] = None,
            description: Optional[pulumi.Input[str]] = None,
            discard: Optional[pulumi.Input[str]] = None,
            discard_new_per_subject: Optional[pulumi.Input[bool]] = None,
            duplicate_window: Optional[pulumi.Input[int]] = None,
            max_age: Optional[pulumi.Input[int]] = None,
            max_bytes: Optional[pulumi.Input[int]] = None,
            max_consumers: Optional[pulumi.Input[int]] = None,
            max_msg_size: Optional[pulumi.Input[int]] = None,
            max_msgs: Optional[pulumi.Input[int]] = None,
            max_msgs_per_subject: Optional[pulumi.Input[int]] = None,
            metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            mirror: Optional[pulumi.Input[pulumi.InputType['StreamMirrorArgs']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            placement_cluster: Optional[pulumi.Input[str]] = None,
            placement_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            replicas: Optional[pulumi.Input[int]] = None,
            republish_destination: Optional[pulumi.Input[str]] = None,
            republish_headers_only: Optional[pulumi.Input[bool]] = None,
            republish_source: Optional[pulumi.Input[str]] = None,
            retention: Optional[pulumi.Input[str]] = None,
            sources: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StreamSourceArgs']]]]] = None,
            storage: Optional[pulumi.Input[str]] = None,
            subject_transform: Optional[pulumi.Input[pulumi.InputType['StreamSubjectTransformArgs']]] = None,
            subjects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None) -> 'Stream':
        """
        Get an existing Stream resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] ack: If the Stream should support confirming receiving messages via acknowledgements
        :param pulumi.Input[bool] allow_direct: Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        :param pulumi.Input[bool] allow_rollup_hdrs: Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        :param pulumi.Input[str] compression: Optional compression algorithm used for the Stream
        :param pulumi.Input[bool] deny_delete: Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        :param pulumi.Input[bool] deny_purge: Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        :param pulumi.Input[str] description: Contains additional information about this stream
        :param pulumi.Input[str] discard: When a Stream reach it's limits either old messages are deleted or new ones are denied
        :param pulumi.Input[bool] discard_new_per_subject: When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        :param pulumi.Input[int] duplicate_window: The size of the duplicate tracking windows, duration specified in seconds
        :param pulumi.Input[int] max_age: The maximum oldest message that can be kept in the stream, duration specified in seconds
        :param pulumi.Input[int] max_bytes: The maximum size of all messages that can be kept in the stream
        :param pulumi.Input[int] max_consumers: Number of consumers this stream allows
        :param pulumi.Input[int] max_msg_size: The maximum individual message size that the stream will accept
        :param pulumi.Input[int] max_msgs: The maximum amount of messages that can be kept in the stream
        :param pulumi.Input[int] max_msgs_per_subject: The maximum amount of messages that can be kept in the stream on a per-subject basis
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Free form metadata about the stream
        :param pulumi.Input[pulumi.InputType['StreamMirrorArgs']] mirror: Specifies a remote stream to mirror into this one
        :param pulumi.Input[str] name: The name of the source Stream
        :param pulumi.Input[str] placement_cluster: Place the stream in a specific cluster, influenced by placement_tags
        :param pulumi.Input[Sequence[pulumi.Input[str]]] placement_tags: Place the stream only on servers with these tags
        :param pulumi.Input[int] replicas: How many replicas of the data to keep in a clustered environment
        :param pulumi.Input[str] republish_destination: The destination to publish messages to
        :param pulumi.Input[bool] republish_headers_only: Republish only message headers, no bodies
        :param pulumi.Input[str] republish_source: Republish messages to republish_destination
        :param pulumi.Input[str] retention: The retention policy to apply over and above max*msgs, max*bytes and max_age
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StreamSourceArgs']]]] sources: The subject transform source
        :param pulumi.Input[str] storage: The storage engine to use to back the stream
        :param pulumi.Input[pulumi.InputType['StreamSubjectTransformArgs']] subject_transform: The subject filtering sources and associated destination transforms
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subjects: The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _StreamState.__new__(_StreamState)

        __props__.__dict__["ack"] = ack
        __props__.__dict__["allow_direct"] = allow_direct
        __props__.__dict__["allow_rollup_hdrs"] = allow_rollup_hdrs
        __props__.__dict__["compression"] = compression
        __props__.__dict__["deny_delete"] = deny_delete
        __props__.__dict__["deny_purge"] = deny_purge
        __props__.__dict__["description"] = description
        __props__.__dict__["discard"] = discard
        __props__.__dict__["discard_new_per_subject"] = discard_new_per_subject
        __props__.__dict__["duplicate_window"] = duplicate_window
        __props__.__dict__["max_age"] = max_age
        __props__.__dict__["max_bytes"] = max_bytes
        __props__.__dict__["max_consumers"] = max_consumers
        __props__.__dict__["max_msg_size"] = max_msg_size
        __props__.__dict__["max_msgs"] = max_msgs
        __props__.__dict__["max_msgs_per_subject"] = max_msgs_per_subject
        __props__.__dict__["metadata"] = metadata
        __props__.__dict__["mirror"] = mirror
        __props__.__dict__["name"] = name
        __props__.__dict__["placement_cluster"] = placement_cluster
        __props__.__dict__["placement_tags"] = placement_tags
        __props__.__dict__["replicas"] = replicas
        __props__.__dict__["republish_destination"] = republish_destination
        __props__.__dict__["republish_headers_only"] = republish_headers_only
        __props__.__dict__["republish_source"] = republish_source
        __props__.__dict__["retention"] = retention
        __props__.__dict__["sources"] = sources
        __props__.__dict__["storage"] = storage
        __props__.__dict__["subject_transform"] = subject_transform
        __props__.__dict__["subjects"] = subjects
        return Stream(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ack(self) -> pulumi.Output[Optional[bool]]:
        """
        If the Stream should support confirming receiving messages via acknowledgements
        """
        return pulumi.get(self, "ack")

    @property
    @pulumi.getter(name="allowDirect")
    def allow_direct(self) -> pulumi.Output[Optional[bool]]:
        """
        Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        """
        return pulumi.get(self, "allow_direct")

    @property
    @pulumi.getter(name="allowRollupHdrs")
    def allow_rollup_hdrs(self) -> pulumi.Output[Optional[bool]]:
        """
        Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        """
        return pulumi.get(self, "allow_rollup_hdrs")

    @property
    @pulumi.getter
    def compression(self) -> pulumi.Output[Optional[str]]:
        """
        Optional compression algorithm used for the Stream
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="denyDelete")
    def deny_delete(self) -> pulumi.Output[Optional[bool]]:
        """
        Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        """
        return pulumi.get(self, "deny_delete")

    @property
    @pulumi.getter(name="denyPurge")
    def deny_purge(self) -> pulumi.Output[Optional[bool]]:
        """
        Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        """
        return pulumi.get(self, "deny_purge")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        Contains additional information about this stream
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def discard(self) -> pulumi.Output[Optional[str]]:
        """
        When a Stream reach it's limits either old messages are deleted or new ones are denied
        """
        return pulumi.get(self, "discard")

    @property
    @pulumi.getter(name="discardNewPerSubject")
    def discard_new_per_subject(self) -> pulumi.Output[Optional[bool]]:
        """
        When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        """
        return pulumi.get(self, "discard_new_per_subject")

    @property
    @pulumi.getter(name="duplicateWindow")
    def duplicate_window(self) -> pulumi.Output[Optional[int]]:
        """
        The size of the duplicate tracking windows, duration specified in seconds
        """
        return pulumi.get(self, "duplicate_window")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> pulumi.Output[Optional[int]]:
        """
        The maximum oldest message that can be kept in the stream, duration specified in seconds
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> pulumi.Output[Optional[int]]:
        """
        The maximum size of all messages that can be kept in the stream
        """
        return pulumi.get(self, "max_bytes")

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> pulumi.Output[Optional[int]]:
        """
        Number of consumers this stream allows
        """
        return pulumi.get(self, "max_consumers")

    @property
    @pulumi.getter(name="maxMsgSize")
    def max_msg_size(self) -> pulumi.Output[Optional[int]]:
        """
        The maximum individual message size that the stream will accept
        """
        return pulumi.get(self, "max_msg_size")

    @property
    @pulumi.getter(name="maxMsgs")
    def max_msgs(self) -> pulumi.Output[Optional[int]]:
        """
        The maximum amount of messages that can be kept in the stream
        """
        return pulumi.get(self, "max_msgs")

    @property
    @pulumi.getter(name="maxMsgsPerSubject")
    def max_msgs_per_subject(self) -> pulumi.Output[Optional[int]]:
        """
        The maximum amount of messages that can be kept in the stream on a per-subject basis
        """
        return pulumi.get(self, "max_msgs_per_subject")

    @property
    @pulumi.getter
    def metadata(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        Free form metadata about the stream
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def mirror(self) -> pulumi.Output[Optional['outputs.StreamMirror']]:
        """
        Specifies a remote stream to mirror into this one
        """
        return pulumi.get(self, "mirror")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the source Stream
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="placementCluster")
    def placement_cluster(self) -> pulumi.Output[Optional[str]]:
        """
        Place the stream in a specific cluster, influenced by placement_tags
        """
        return pulumi.get(self, "placement_cluster")

    @property
    @pulumi.getter(name="placementTags")
    def placement_tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        Place the stream only on servers with these tags
        """
        return pulumi.get(self, "placement_tags")

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Output[Optional[int]]:
        """
        How many replicas of the data to keep in a clustered environment
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="republishDestination")
    def republish_destination(self) -> pulumi.Output[Optional[str]]:
        """
        The destination to publish messages to
        """
        return pulumi.get(self, "republish_destination")

    @property
    @pulumi.getter(name="republishHeadersOnly")
    def republish_headers_only(self) -> pulumi.Output[Optional[bool]]:
        """
        Republish only message headers, no bodies
        """
        return pulumi.get(self, "republish_headers_only")

    @property
    @pulumi.getter(name="republishSource")
    def republish_source(self) -> pulumi.Output[Optional[str]]:
        """
        Republish messages to republish_destination
        """
        return pulumi.get(self, "republish_source")

    @property
    @pulumi.getter
    def retention(self) -> pulumi.Output[Optional[str]]:
        """
        The retention policy to apply over and above max*msgs, max*bytes and max_age
        """
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Output[Optional[Sequence['outputs.StreamSource']]]:
        """
        The subject transform source
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Output[Optional[str]]:
        """
        The storage engine to use to back the stream
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="subjectTransform")
    def subject_transform(self) -> pulumi.Output[Optional['outputs.StreamSubjectTransform']]:
        """
        The subject filtering sources and associated destination transforms
        """
        return pulumi.get(self, "subject_transform")

    @property
    @pulumi.getter
    def subjects(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        """
        return pulumi.get(self, "subjects")


// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package jetstream

import (
	"context"
	"reflect"

	"errors"
	"github.com/Triple-Whale/pulumi-jetstream/sdk/go/jetstream/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Consumer struct {
	pulumi.CustomResourceState

	// The delivery acknowledgement policy to apply to the Consumer
	AckPolicy pulumi.StringPtrOutput `pulumi:"ackPolicy"`
	// Number of seconds to wait for acknowledgement
	AckWait pulumi.IntPtrOutput `pulumi:"ackWait"`
	// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
	Backoffs pulumi.IntArrayOutput `pulumi:"backoffs"`
	// Starts at the first available message in the Stream
	DeliverAll pulumi.BoolPtrOutput `pulumi:"deliverAll"`
	// Starts at the latest available message in the Stream
	DeliverLast pulumi.BoolPtrOutput `pulumi:"deliverLast"`
	// Starts with the last message for each subject matched by filter
	DeliverLastPerSubject pulumi.BoolPtrOutput `pulumi:"deliverLastPerSubject"`
	// Starts with the next available message in the Stream
	DeliverNew pulumi.BoolPtrOutput `pulumi:"deliverNew"`
	// When set Push consumers will only deliver messages to subscriptions with this group set
	DeliveryGroup pulumi.StringPtrOutput `pulumi:"deliveryGroup"`
	// The subject where a Push-based consumer will deliver messages
	DeliverySubject pulumi.StringPtrOutput `pulumi:"deliverySubject"`
	// Contains additional information about this consumer
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The durable name of the Consumer
	DurableName pulumi.StringOutput `pulumi:"durableName"`
	// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
	FilterSubject pulumi.StringPtrOutput `pulumi:"filterSubject"`
	// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
	FilterSubjects pulumi.StringArrayOutput `pulumi:"filterSubjects"`
	// Enable flow control for push consumers
	FlowControl pulumi.BoolPtrOutput `pulumi:"flowControl"`
	// When true no message bodies will be delivered only headers
	HeadersOnly pulumi.BoolPtrOutput `pulumi:"headersOnly"`
	// Enable heartbeat messages for push consumers, duration specified in seconds
	Heartbeat pulumi.IntPtrOutput `pulumi:"heartbeat"`
	// Removes the consumer after a idle period, specified as a duration in seconds
	InactiveThreshold pulumi.IntPtrOutput `pulumi:"inactiveThreshold"`
	// Maximum pending Acks before consumers are paused
	MaxAckPending pulumi.IntPtrOutput `pulumi:"maxAckPending"`
	// Limits Pull Batch sizes to this maximum
	MaxBatch pulumi.IntPtrOutput `pulumi:"maxBatch"`
	// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
	MaxBytes pulumi.IntPtrOutput `pulumi:"maxBytes"`
	// Maximum deliveries to attempt for each message
	MaxDelivery pulumi.IntPtrOutput `pulumi:"maxDelivery"`
	// Limits the Pull Expires duration to this maximum in seconds
	MaxExpires pulumi.IntPtrOutput `pulumi:"maxExpires"`
	// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
	MaxWaiting pulumi.IntPtrOutput `pulumi:"maxWaiting"`
	// Force the consumer state to be kept in memory rather than inherit the setting from the stream
	Memory pulumi.BoolPtrOutput `pulumi:"memory"`
	// Free form metadata about the consumer
	Metadata pulumi.StringMapOutput `pulumi:"metadata"`
	// The rate limit for delivering messages to push consumers, expressed in bits per second
	Ratelimit pulumi.IntPtrOutput `pulumi:"ratelimit"`
	// The rate at which messages will be replayed from the stream
	ReplayPolicy pulumi.StringPtrOutput `pulumi:"replayPolicy"`
	// How many replicas of the data to keep in a clustered environment
	Replicas pulumi.IntPtrOutput `pulumi:"replicas"`
	// The percentage of acknowledgements that will be sampled for observability purposes
	SampleFreq pulumi.IntPtrOutput `pulumi:"sampleFreq"`
	// The timestamp of the first message that will be delivered by this Consumer
	StartTime pulumi.StringPtrOutput `pulumi:"startTime"`
	// The name of the Stream that this consumer consumes
	StreamId pulumi.StringOutput `pulumi:"streamId"`
	// The Stream Sequence that will be the first message delivered by this Consumer
	StreamSequence pulumi.IntPtrOutput `pulumi:"streamSequence"`
}

// NewConsumer registers a new resource with the given unique name, arguments, and options.
func NewConsumer(ctx *pulumi.Context,
	name string, args *ConsumerArgs, opts ...pulumi.ResourceOption) (*Consumer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DurableName == nil {
		return nil, errors.New("invalid value for required argument 'DurableName'")
	}
	if args.StreamId == nil {
		return nil, errors.New("invalid value for required argument 'StreamId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Consumer
	err := ctx.RegisterResource("jetstream:index/consumer:Consumer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConsumer gets an existing Consumer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConsumer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConsumerState, opts ...pulumi.ResourceOption) (*Consumer, error) {
	var resource Consumer
	err := ctx.ReadResource("jetstream:index/consumer:Consumer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Consumer resources.
type consumerState struct {
	// The delivery acknowledgement policy to apply to the Consumer
	AckPolicy *string `pulumi:"ackPolicy"`
	// Number of seconds to wait for acknowledgement
	AckWait *int `pulumi:"ackWait"`
	// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
	Backoffs []int `pulumi:"backoffs"`
	// Starts at the first available message in the Stream
	DeliverAll *bool `pulumi:"deliverAll"`
	// Starts at the latest available message in the Stream
	DeliverLast *bool `pulumi:"deliverLast"`
	// Starts with the last message for each subject matched by filter
	DeliverLastPerSubject *bool `pulumi:"deliverLastPerSubject"`
	// Starts with the next available message in the Stream
	DeliverNew *bool `pulumi:"deliverNew"`
	// When set Push consumers will only deliver messages to subscriptions with this group set
	DeliveryGroup *string `pulumi:"deliveryGroup"`
	// The subject where a Push-based consumer will deliver messages
	DeliverySubject *string `pulumi:"deliverySubject"`
	// Contains additional information about this consumer
	Description *string `pulumi:"description"`
	// The durable name of the Consumer
	DurableName *string `pulumi:"durableName"`
	// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
	FilterSubject *string `pulumi:"filterSubject"`
	// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
	FilterSubjects []string `pulumi:"filterSubjects"`
	// Enable flow control for push consumers
	FlowControl *bool `pulumi:"flowControl"`
	// When true no message bodies will be delivered only headers
	HeadersOnly *bool `pulumi:"headersOnly"`
	// Enable heartbeat messages for push consumers, duration specified in seconds
	Heartbeat *int `pulumi:"heartbeat"`
	// Removes the consumer after a idle period, specified as a duration in seconds
	InactiveThreshold *int `pulumi:"inactiveThreshold"`
	// Maximum pending Acks before consumers are paused
	MaxAckPending *int `pulumi:"maxAckPending"`
	// Limits Pull Batch sizes to this maximum
	MaxBatch *int `pulumi:"maxBatch"`
	// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
	MaxBytes *int `pulumi:"maxBytes"`
	// Maximum deliveries to attempt for each message
	MaxDelivery *int `pulumi:"maxDelivery"`
	// Limits the Pull Expires duration to this maximum in seconds
	MaxExpires *int `pulumi:"maxExpires"`
	// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
	MaxWaiting *int `pulumi:"maxWaiting"`
	// Force the consumer state to be kept in memory rather than inherit the setting from the stream
	Memory *bool `pulumi:"memory"`
	// Free form metadata about the consumer
	Metadata map[string]string `pulumi:"metadata"`
	// The rate limit for delivering messages to push consumers, expressed in bits per second
	Ratelimit *int `pulumi:"ratelimit"`
	// The rate at which messages will be replayed from the stream
	ReplayPolicy *string `pulumi:"replayPolicy"`
	// How many replicas of the data to keep in a clustered environment
	Replicas *int `pulumi:"replicas"`
	// The percentage of acknowledgements that will be sampled for observability purposes
	SampleFreq *int `pulumi:"sampleFreq"`
	// The timestamp of the first message that will be delivered by this Consumer
	StartTime *string `pulumi:"startTime"`
	// The name of the Stream that this consumer consumes
	StreamId *string `pulumi:"streamId"`
	// The Stream Sequence that will be the first message delivered by this Consumer
	StreamSequence *int `pulumi:"streamSequence"`
}

type ConsumerState struct {
	// The delivery acknowledgement policy to apply to the Consumer
	AckPolicy pulumi.StringPtrInput
	// Number of seconds to wait for acknowledgement
	AckWait pulumi.IntPtrInput
	// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
	Backoffs pulumi.IntArrayInput
	// Starts at the first available message in the Stream
	DeliverAll pulumi.BoolPtrInput
	// Starts at the latest available message in the Stream
	DeliverLast pulumi.BoolPtrInput
	// Starts with the last message for each subject matched by filter
	DeliverLastPerSubject pulumi.BoolPtrInput
	// Starts with the next available message in the Stream
	DeliverNew pulumi.BoolPtrInput
	// When set Push consumers will only deliver messages to subscriptions with this group set
	DeliveryGroup pulumi.StringPtrInput
	// The subject where a Push-based consumer will deliver messages
	DeliverySubject pulumi.StringPtrInput
	// Contains additional information about this consumer
	Description pulumi.StringPtrInput
	// The durable name of the Consumer
	DurableName pulumi.StringPtrInput
	// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
	FilterSubject pulumi.StringPtrInput
	// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
	FilterSubjects pulumi.StringArrayInput
	// Enable flow control for push consumers
	FlowControl pulumi.BoolPtrInput
	// When true no message bodies will be delivered only headers
	HeadersOnly pulumi.BoolPtrInput
	// Enable heartbeat messages for push consumers, duration specified in seconds
	Heartbeat pulumi.IntPtrInput
	// Removes the consumer after a idle period, specified as a duration in seconds
	InactiveThreshold pulumi.IntPtrInput
	// Maximum pending Acks before consumers are paused
	MaxAckPending pulumi.IntPtrInput
	// Limits Pull Batch sizes to this maximum
	MaxBatch pulumi.IntPtrInput
	// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
	MaxBytes pulumi.IntPtrInput
	// Maximum deliveries to attempt for each message
	MaxDelivery pulumi.IntPtrInput
	// Limits the Pull Expires duration to this maximum in seconds
	MaxExpires pulumi.IntPtrInput
	// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
	MaxWaiting pulumi.IntPtrInput
	// Force the consumer state to be kept in memory rather than inherit the setting from the stream
	Memory pulumi.BoolPtrInput
	// Free form metadata about the consumer
	Metadata pulumi.StringMapInput
	// The rate limit for delivering messages to push consumers, expressed in bits per second
	Ratelimit pulumi.IntPtrInput
	// The rate at which messages will be replayed from the stream
	ReplayPolicy pulumi.StringPtrInput
	// How many replicas of the data to keep in a clustered environment
	Replicas pulumi.IntPtrInput
	// The percentage of acknowledgements that will be sampled for observability purposes
	SampleFreq pulumi.IntPtrInput
	// The timestamp of the first message that will be delivered by this Consumer
	StartTime pulumi.StringPtrInput
	// The name of the Stream that this consumer consumes
	StreamId pulumi.StringPtrInput
	// The Stream Sequence that will be the first message delivered by this Consumer
	StreamSequence pulumi.IntPtrInput
}

func (ConsumerState) ElementType() reflect.Type {
	return reflect.TypeOf((*consumerState)(nil)).Elem()
}

type consumerArgs struct {
	// The delivery acknowledgement policy to apply to the Consumer
	AckPolicy *string `pulumi:"ackPolicy"`
	// Number of seconds to wait for acknowledgement
	AckWait *int `pulumi:"ackWait"`
	// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
	Backoffs []int `pulumi:"backoffs"`
	// Starts at the first available message in the Stream
	DeliverAll *bool `pulumi:"deliverAll"`
	// Starts at the latest available message in the Stream
	DeliverLast *bool `pulumi:"deliverLast"`
	// Starts with the last message for each subject matched by filter
	DeliverLastPerSubject *bool `pulumi:"deliverLastPerSubject"`
	// Starts with the next available message in the Stream
	DeliverNew *bool `pulumi:"deliverNew"`
	// When set Push consumers will only deliver messages to subscriptions with this group set
	DeliveryGroup *string `pulumi:"deliveryGroup"`
	// The subject where a Push-based consumer will deliver messages
	DeliverySubject *string `pulumi:"deliverySubject"`
	// Contains additional information about this consumer
	Description *string `pulumi:"description"`
	// The durable name of the Consumer
	DurableName string `pulumi:"durableName"`
	// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
	FilterSubject *string `pulumi:"filterSubject"`
	// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
	FilterSubjects []string `pulumi:"filterSubjects"`
	// Enable flow control for push consumers
	FlowControl *bool `pulumi:"flowControl"`
	// When true no message bodies will be delivered only headers
	HeadersOnly *bool `pulumi:"headersOnly"`
	// Enable heartbeat messages for push consumers, duration specified in seconds
	Heartbeat *int `pulumi:"heartbeat"`
	// Removes the consumer after a idle period, specified as a duration in seconds
	InactiveThreshold *int `pulumi:"inactiveThreshold"`
	// Maximum pending Acks before consumers are paused
	MaxAckPending *int `pulumi:"maxAckPending"`
	// Limits Pull Batch sizes to this maximum
	MaxBatch *int `pulumi:"maxBatch"`
	// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
	MaxBytes *int `pulumi:"maxBytes"`
	// Maximum deliveries to attempt for each message
	MaxDelivery *int `pulumi:"maxDelivery"`
	// Limits the Pull Expires duration to this maximum in seconds
	MaxExpires *int `pulumi:"maxExpires"`
	// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
	MaxWaiting *int `pulumi:"maxWaiting"`
	// Force the consumer state to be kept in memory rather than inherit the setting from the stream
	Memory *bool `pulumi:"memory"`
	// Free form metadata about the consumer
	Metadata map[string]string `pulumi:"metadata"`
	// The rate limit for delivering messages to push consumers, expressed in bits per second
	Ratelimit *int `pulumi:"ratelimit"`
	// The rate at which messages will be replayed from the stream
	ReplayPolicy *string `pulumi:"replayPolicy"`
	// How many replicas of the data to keep in a clustered environment
	Replicas *int `pulumi:"replicas"`
	// The percentage of acknowledgements that will be sampled for observability purposes
	SampleFreq *int `pulumi:"sampleFreq"`
	// The timestamp of the first message that will be delivered by this Consumer
	StartTime *string `pulumi:"startTime"`
	// The name of the Stream that this consumer consumes
	StreamId string `pulumi:"streamId"`
	// The Stream Sequence that will be the first message delivered by this Consumer
	StreamSequence *int `pulumi:"streamSequence"`
}

// The set of arguments for constructing a Consumer resource.
type ConsumerArgs struct {
	// The delivery acknowledgement policy to apply to the Consumer
	AckPolicy pulumi.StringPtrInput
	// Number of seconds to wait for acknowledgement
	AckWait pulumi.IntPtrInput
	// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
	Backoffs pulumi.IntArrayInput
	// Starts at the first available message in the Stream
	DeliverAll pulumi.BoolPtrInput
	// Starts at the latest available message in the Stream
	DeliverLast pulumi.BoolPtrInput
	// Starts with the last message for each subject matched by filter
	DeliverLastPerSubject pulumi.BoolPtrInput
	// Starts with the next available message in the Stream
	DeliverNew pulumi.BoolPtrInput
	// When set Push consumers will only deliver messages to subscriptions with this group set
	DeliveryGroup pulumi.StringPtrInput
	// The subject where a Push-based consumer will deliver messages
	DeliverySubject pulumi.StringPtrInput
	// Contains additional information about this consumer
	Description pulumi.StringPtrInput
	// The durable name of the Consumer
	DurableName pulumi.StringInput
	// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
	FilterSubject pulumi.StringPtrInput
	// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
	FilterSubjects pulumi.StringArrayInput
	// Enable flow control for push consumers
	FlowControl pulumi.BoolPtrInput
	// When true no message bodies will be delivered only headers
	HeadersOnly pulumi.BoolPtrInput
	// Enable heartbeat messages for push consumers, duration specified in seconds
	Heartbeat pulumi.IntPtrInput
	// Removes the consumer after a idle period, specified as a duration in seconds
	InactiveThreshold pulumi.IntPtrInput
	// Maximum pending Acks before consumers are paused
	MaxAckPending pulumi.IntPtrInput
	// Limits Pull Batch sizes to this maximum
	MaxBatch pulumi.IntPtrInput
	// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
	MaxBytes pulumi.IntPtrInput
	// Maximum deliveries to attempt for each message
	MaxDelivery pulumi.IntPtrInput
	// Limits the Pull Expires duration to this maximum in seconds
	MaxExpires pulumi.IntPtrInput
	// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
	MaxWaiting pulumi.IntPtrInput
	// Force the consumer state to be kept in memory rather than inherit the setting from the stream
	Memory pulumi.BoolPtrInput
	// Free form metadata about the consumer
	Metadata pulumi.StringMapInput
	// The rate limit for delivering messages to push consumers, expressed in bits per second
	Ratelimit pulumi.IntPtrInput
	// The rate at which messages will be replayed from the stream
	ReplayPolicy pulumi.StringPtrInput
	// How many replicas of the data to keep in a clustered environment
	Replicas pulumi.IntPtrInput
	// The percentage of acknowledgements that will be sampled for observability purposes
	SampleFreq pulumi.IntPtrInput
	// The timestamp of the first message that will be delivered by this Consumer
	StartTime pulumi.StringPtrInput
	// The name of the Stream that this consumer consumes
	StreamId pulumi.StringInput
	// The Stream Sequence that will be the first message delivered by this Consumer
	StreamSequence pulumi.IntPtrInput
}

func (ConsumerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*consumerArgs)(nil)).Elem()
}

type ConsumerInput interface {
	pulumi.Input

	ToConsumerOutput() ConsumerOutput
	ToConsumerOutputWithContext(ctx context.Context) ConsumerOutput
}

func (*Consumer) ElementType() reflect.Type {
	return reflect.TypeOf((**Consumer)(nil)).Elem()
}

func (i *Consumer) ToConsumerOutput() ConsumerOutput {
	return i.ToConsumerOutputWithContext(context.Background())
}

func (i *Consumer) ToConsumerOutputWithContext(ctx context.Context) ConsumerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsumerOutput)
}

// ConsumerArrayInput is an input type that accepts ConsumerArray and ConsumerArrayOutput values.
// You can construct a concrete instance of `ConsumerArrayInput` via:
//
//	ConsumerArray{ ConsumerArgs{...} }
type ConsumerArrayInput interface {
	pulumi.Input

	ToConsumerArrayOutput() ConsumerArrayOutput
	ToConsumerArrayOutputWithContext(context.Context) ConsumerArrayOutput
}

type ConsumerArray []ConsumerInput

func (ConsumerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Consumer)(nil)).Elem()
}

func (i ConsumerArray) ToConsumerArrayOutput() ConsumerArrayOutput {
	return i.ToConsumerArrayOutputWithContext(context.Background())
}

func (i ConsumerArray) ToConsumerArrayOutputWithContext(ctx context.Context) ConsumerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsumerArrayOutput)
}

// ConsumerMapInput is an input type that accepts ConsumerMap and ConsumerMapOutput values.
// You can construct a concrete instance of `ConsumerMapInput` via:
//
//	ConsumerMap{ "key": ConsumerArgs{...} }
type ConsumerMapInput interface {
	pulumi.Input

	ToConsumerMapOutput() ConsumerMapOutput
	ToConsumerMapOutputWithContext(context.Context) ConsumerMapOutput
}

type ConsumerMap map[string]ConsumerInput

func (ConsumerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Consumer)(nil)).Elem()
}

func (i ConsumerMap) ToConsumerMapOutput() ConsumerMapOutput {
	return i.ToConsumerMapOutputWithContext(context.Background())
}

func (i ConsumerMap) ToConsumerMapOutputWithContext(ctx context.Context) ConsumerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConsumerMapOutput)
}

type ConsumerOutput struct{ *pulumi.OutputState }

func (ConsumerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Consumer)(nil)).Elem()
}

func (o ConsumerOutput) ToConsumerOutput() ConsumerOutput {
	return o
}

func (o ConsumerOutput) ToConsumerOutputWithContext(ctx context.Context) ConsumerOutput {
	return o
}

// The delivery acknowledgement policy to apply to the Consumer
func (o ConsumerOutput) AckPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.AckPolicy }).(pulumi.StringPtrOutput)
}

// Number of seconds to wait for acknowledgement
func (o ConsumerOutput) AckWait() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.AckWait }).(pulumi.IntPtrOutput)
}

// List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
func (o ConsumerOutput) Backoffs() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntArrayOutput { return v.Backoffs }).(pulumi.IntArrayOutput)
}

// Starts at the first available message in the Stream
func (o ConsumerOutput) DeliverAll() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.DeliverAll }).(pulumi.BoolPtrOutput)
}

// Starts at the latest available message in the Stream
func (o ConsumerOutput) DeliverLast() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.DeliverLast }).(pulumi.BoolPtrOutput)
}

// Starts with the last message for each subject matched by filter
func (o ConsumerOutput) DeliverLastPerSubject() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.DeliverLastPerSubject }).(pulumi.BoolPtrOutput)
}

// Starts with the next available message in the Stream
func (o ConsumerOutput) DeliverNew() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.DeliverNew }).(pulumi.BoolPtrOutput)
}

// When set Push consumers will only deliver messages to subscriptions with this group set
func (o ConsumerOutput) DeliveryGroup() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.DeliveryGroup }).(pulumi.StringPtrOutput)
}

// The subject where a Push-based consumer will deliver messages
func (o ConsumerOutput) DeliverySubject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.DeliverySubject }).(pulumi.StringPtrOutput)
}

// Contains additional information about this consumer
func (o ConsumerOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The durable name of the Consumer
func (o ConsumerOutput) DurableName() pulumi.StringOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringOutput { return v.DurableName }).(pulumi.StringOutput)
}

// Only receive a subset of messages from the Stream based on the subject they entered the Stream on
func (o ConsumerOutput) FilterSubject() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.FilterSubject }).(pulumi.StringPtrOutput)
}

// Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to filterSubject and works with nats-server v2.10 or better
func (o ConsumerOutput) FilterSubjects() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringArrayOutput { return v.FilterSubjects }).(pulumi.StringArrayOutput)
}

// Enable flow control for push consumers
func (o ConsumerOutput) FlowControl() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.FlowControl }).(pulumi.BoolPtrOutput)
}

// When true no message bodies will be delivered only headers
func (o ConsumerOutput) HeadersOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.HeadersOnly }).(pulumi.BoolPtrOutput)
}

// Enable heartbeat messages for push consumers, duration specified in seconds
func (o ConsumerOutput) Heartbeat() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.Heartbeat }).(pulumi.IntPtrOutput)
}

// Removes the consumer after a idle period, specified as a duration in seconds
func (o ConsumerOutput) InactiveThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.InactiveThreshold }).(pulumi.IntPtrOutput)
}

// Maximum pending Acks before consumers are paused
func (o ConsumerOutput) MaxAckPending() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxAckPending }).(pulumi.IntPtrOutput)
}

// Limits Pull Batch sizes to this maximum
func (o ConsumerOutput) MaxBatch() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxBatch }).(pulumi.IntPtrOutput)
}

// The maximum bytes value that maybe set when dong a pull on a Pull Consumer
func (o ConsumerOutput) MaxBytes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxBytes }).(pulumi.IntPtrOutput)
}

// Maximum deliveries to attempt for each message
func (o ConsumerOutput) MaxDelivery() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxDelivery }).(pulumi.IntPtrOutput)
}

// Limits the Pull Expires duration to this maximum in seconds
func (o ConsumerOutput) MaxExpires() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxExpires }).(pulumi.IntPtrOutput)
}

// The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
func (o ConsumerOutput) MaxWaiting() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.MaxWaiting }).(pulumi.IntPtrOutput)
}

// Force the consumer state to be kept in memory rather than inherit the setting from the stream
func (o ConsumerOutput) Memory() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.BoolPtrOutput { return v.Memory }).(pulumi.BoolPtrOutput)
}

// Free form metadata about the consumer
func (o ConsumerOutput) Metadata() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringMapOutput { return v.Metadata }).(pulumi.StringMapOutput)
}

// The rate limit for delivering messages to push consumers, expressed in bits per second
func (o ConsumerOutput) Ratelimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.Ratelimit }).(pulumi.IntPtrOutput)
}

// The rate at which messages will be replayed from the stream
func (o ConsumerOutput) ReplayPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.ReplayPolicy }).(pulumi.StringPtrOutput)
}

// How many replicas of the data to keep in a clustered environment
func (o ConsumerOutput) Replicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.Replicas }).(pulumi.IntPtrOutput)
}

// The percentage of acknowledgements that will be sampled for observability purposes
func (o ConsumerOutput) SampleFreq() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.SampleFreq }).(pulumi.IntPtrOutput)
}

// The timestamp of the first message that will be delivered by this Consumer
func (o ConsumerOutput) StartTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringPtrOutput { return v.StartTime }).(pulumi.StringPtrOutput)
}

// The name of the Stream that this consumer consumes
func (o ConsumerOutput) StreamId() pulumi.StringOutput {
	return o.ApplyT(func(v *Consumer) pulumi.StringOutput { return v.StreamId }).(pulumi.StringOutput)
}

// The Stream Sequence that will be the first message delivered by this Consumer
func (o ConsumerOutput) StreamSequence() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Consumer) pulumi.IntPtrOutput { return v.StreamSequence }).(pulumi.IntPtrOutput)
}

type ConsumerArrayOutput struct{ *pulumi.OutputState }

func (ConsumerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Consumer)(nil)).Elem()
}

func (o ConsumerArrayOutput) ToConsumerArrayOutput() ConsumerArrayOutput {
	return o
}

func (o ConsumerArrayOutput) ToConsumerArrayOutputWithContext(ctx context.Context) ConsumerArrayOutput {
	return o
}

func (o ConsumerArrayOutput) Index(i pulumi.IntInput) ConsumerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Consumer {
		return vs[0].([]*Consumer)[vs[1].(int)]
	}).(ConsumerOutput)
}

type ConsumerMapOutput struct{ *pulumi.OutputState }

func (ConsumerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Consumer)(nil)).Elem()
}

func (o ConsumerMapOutput) ToConsumerMapOutput() ConsumerMapOutput {
	return o
}

func (o ConsumerMapOutput) ToConsumerMapOutputWithContext(ctx context.Context) ConsumerMapOutput {
	return o
}

func (o ConsumerMapOutput) MapIndex(k pulumi.StringInput) ConsumerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Consumer {
		return vs[0].(map[string]*Consumer)[vs[1].(string)]
	}).(ConsumerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConsumerInput)(nil)).Elem(), &Consumer{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsumerArrayInput)(nil)).Elem(), ConsumerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConsumerMapInput)(nil)).Elem(), ConsumerMap{})
	pulumi.RegisterOutputType(ConsumerOutput{})
	pulumi.RegisterOutputType(ConsumerArrayOutput{})
	pulumi.RegisterOutputType(ConsumerMapOutput{})
}

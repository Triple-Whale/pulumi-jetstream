// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Jetstream
{
    [JetstreamResourceType("jetstream:index/stream:Stream")]
    public partial class Stream : global::Pulumi.CustomResource
    {
        /// <summary>
        /// If the Stream should support confirming receiving messages via acknowledgements
        /// </summary>
        [Output("ack")]
        public Output<bool?> Ack { get; private set; } = null!;

        /// <summary>
        /// Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        /// </summary>
        [Output("allowDirect")]
        public Output<bool?> AllowDirect { get; private set; } = null!;

        /// <summary>
        /// Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        /// </summary>
        [Output("allowRollupHdrs")]
        public Output<bool?> AllowRollupHdrs { get; private set; } = null!;

        /// <summary>
        /// Optional compression algorithm used for the Stream
        /// </summary>
        [Output("compression")]
        public Output<string?> Compression { get; private set; } = null!;

        /// <summary>
        /// Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        /// </summary>
        [Output("denyDelete")]
        public Output<bool?> DenyDelete { get; private set; } = null!;

        /// <summary>
        /// Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        /// </summary>
        [Output("denyPurge")]
        public Output<bool?> DenyPurge { get; private set; } = null!;

        /// <summary>
        /// Contains additional information about this stream
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// When a Stream reach it's limits either old messages are deleted or new ones are denied
        /// </summary>
        [Output("discard")]
        public Output<string?> Discard { get; private set; } = null!;

        /// <summary>
        /// When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        /// </summary>
        [Output("discardNewPerSubject")]
        public Output<bool?> DiscardNewPerSubject { get; private set; } = null!;

        /// <summary>
        /// The size of the duplicate tracking windows, duration specified in seconds
        /// </summary>
        [Output("duplicateWindow")]
        public Output<int?> DuplicateWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum oldest message that can be kept in the stream, duration specified in seconds
        /// </summary>
        [Output("maxAge")]
        public Output<int?> MaxAge { get; private set; } = null!;

        /// <summary>
        /// The maximum size of all messages that can be kept in the stream
        /// </summary>
        [Output("maxBytes")]
        public Output<int?> MaxBytes { get; private set; } = null!;

        /// <summary>
        /// Number of consumers this stream allows
        /// </summary>
        [Output("maxConsumers")]
        public Output<int?> MaxConsumers { get; private set; } = null!;

        /// <summary>
        /// The maximum individual message size that the stream will accept
        /// </summary>
        [Output("maxMsgSize")]
        public Output<int?> MaxMsgSize { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream
        /// </summary>
        [Output("maxMsgs")]
        public Output<int?> MaxMsgs { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream on a per-subject basis
        /// </summary>
        [Output("maxMsgsPerSubject")]
        public Output<int?> MaxMsgsPerSubject { get; private set; } = null!;

        /// <summary>
        /// Free form metadata about the stream
        /// </summary>
        [Output("metadata")]
        public Output<ImmutableDictionary<string, string>?> Metadata { get; private set; } = null!;

        /// <summary>
        /// Specifies a remote stream to mirror into this one
        /// </summary>
        [Output("mirror")]
        public Output<Outputs.StreamMirror?> Mirror { get; private set; } = null!;

        /// <summary>
        /// The name of the source Stream
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Place the stream in a specific cluster, influenced by placement_tags
        /// </summary>
        [Output("placementCluster")]
        public Output<string?> PlacementCluster { get; private set; } = null!;

        /// <summary>
        /// Place the stream only on servers with these tags
        /// </summary>
        [Output("placementTags")]
        public Output<ImmutableArray<string>> PlacementTags { get; private set; } = null!;

        /// <summary>
        /// How many replicas of the data to keep in a clustered environment
        /// </summary>
        [Output("replicas")]
        public Output<int?> Replicas { get; private set; } = null!;

        /// <summary>
        /// The destination to publish messages to
        /// </summary>
        [Output("republishDestination")]
        public Output<string?> RepublishDestination { get; private set; } = null!;

        /// <summary>
        /// Republish only message headers, no bodies
        /// </summary>
        [Output("republishHeadersOnly")]
        public Output<bool?> RepublishHeadersOnly { get; private set; } = null!;

        /// <summary>
        /// Republish messages to republish_destination
        /// </summary>
        [Output("republishSource")]
        public Output<string?> RepublishSource { get; private set; } = null!;

        /// <summary>
        /// The retention policy to apply over and above max*msgs, max*bytes and max_age
        /// </summary>
        [Output("retention")]
        public Output<string?> Retention { get; private set; } = null!;

        /// <summary>
        /// The subject transform source
        /// </summary>
        [Output("sources")]
        public Output<ImmutableArray<Outputs.StreamSource>> Sources { get; private set; } = null!;

        /// <summary>
        /// The storage engine to use to back the stream
        /// </summary>
        [Output("storage")]
        public Output<string?> Storage { get; private set; } = null!;

        /// <summary>
        /// The subject filtering sources and associated destination transforms
        /// </summary>
        [Output("subjectTransform")]
        public Output<Outputs.StreamSubjectTransform?> SubjectTransform { get; private set; } = null!;

        /// <summary>
        /// The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        /// </summary>
        [Output("subjects")]
        public Output<ImmutableArray<string>> Subjects { get; private set; } = null!;


        /// <summary>
        /// Create a Stream resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Stream(string name, StreamArgs? args = null, CustomResourceOptions? options = null)
            : base("jetstream:index/stream:Stream", name, args ?? new StreamArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Stream(string name, Input<string> id, StreamState? state = null, CustomResourceOptions? options = null)
            : base("jetstream:index/stream:Stream", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Stream resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Stream Get(string name, Input<string> id, StreamState? state = null, CustomResourceOptions? options = null)
        {
            return new Stream(name, id, state, options);
        }
    }

    public sealed class StreamArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If the Stream should support confirming receiving messages via acknowledgements
        /// </summary>
        [Input("ack")]
        public Input<bool>? Ack { get; set; }

        /// <summary>
        /// Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        /// </summary>
        [Input("allowDirect")]
        public Input<bool>? AllowDirect { get; set; }

        /// <summary>
        /// Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        /// </summary>
        [Input("allowRollupHdrs")]
        public Input<bool>? AllowRollupHdrs { get; set; }

        /// <summary>
        /// Optional compression algorithm used for the Stream
        /// </summary>
        [Input("compression")]
        public Input<string>? Compression { get; set; }

        /// <summary>
        /// Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        /// </summary>
        [Input("denyDelete")]
        public Input<bool>? DenyDelete { get; set; }

        /// <summary>
        /// Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        /// </summary>
        [Input("denyPurge")]
        public Input<bool>? DenyPurge { get; set; }

        /// <summary>
        /// Contains additional information about this stream
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// When a Stream reach it's limits either old messages are deleted or new ones are denied
        /// </summary>
        [Input("discard")]
        public Input<string>? Discard { get; set; }

        /// <summary>
        /// When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        /// </summary>
        [Input("discardNewPerSubject")]
        public Input<bool>? DiscardNewPerSubject { get; set; }

        /// <summary>
        /// The size of the duplicate tracking windows, duration specified in seconds
        /// </summary>
        [Input("duplicateWindow")]
        public Input<int>? DuplicateWindow { get; set; }

        /// <summary>
        /// The maximum oldest message that can be kept in the stream, duration specified in seconds
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        /// <summary>
        /// The maximum size of all messages that can be kept in the stream
        /// </summary>
        [Input("maxBytes")]
        public Input<int>? MaxBytes { get; set; }

        /// <summary>
        /// Number of consumers this stream allows
        /// </summary>
        [Input("maxConsumers")]
        public Input<int>? MaxConsumers { get; set; }

        /// <summary>
        /// The maximum individual message size that the stream will accept
        /// </summary>
        [Input("maxMsgSize")]
        public Input<int>? MaxMsgSize { get; set; }

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream
        /// </summary>
        [Input("maxMsgs")]
        public Input<int>? MaxMsgs { get; set; }

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream on a per-subject basis
        /// </summary>
        [Input("maxMsgsPerSubject")]
        public Input<int>? MaxMsgsPerSubject { get; set; }

        [Input("metadata")]
        private InputMap<string>? _metadata;

        /// <summary>
        /// Free form metadata about the stream
        /// </summary>
        public InputMap<string> Metadata
        {
            get => _metadata ?? (_metadata = new InputMap<string>());
            set => _metadata = value;
        }

        /// <summary>
        /// Specifies a remote stream to mirror into this one
        /// </summary>
        [Input("mirror")]
        public Input<Inputs.StreamMirrorArgs>? Mirror { get; set; }

        /// <summary>
        /// The name of the source Stream
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Place the stream in a specific cluster, influenced by placement_tags
        /// </summary>
        [Input("placementCluster")]
        public Input<string>? PlacementCluster { get; set; }

        [Input("placementTags")]
        private InputList<string>? _placementTags;

        /// <summary>
        /// Place the stream only on servers with these tags
        /// </summary>
        public InputList<string> PlacementTags
        {
            get => _placementTags ?? (_placementTags = new InputList<string>());
            set => _placementTags = value;
        }

        /// <summary>
        /// How many replicas of the data to keep in a clustered environment
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The destination to publish messages to
        /// </summary>
        [Input("republishDestination")]
        public Input<string>? RepublishDestination { get; set; }

        /// <summary>
        /// Republish only message headers, no bodies
        /// </summary>
        [Input("republishHeadersOnly")]
        public Input<bool>? RepublishHeadersOnly { get; set; }

        /// <summary>
        /// Republish messages to republish_destination
        /// </summary>
        [Input("republishSource")]
        public Input<string>? RepublishSource { get; set; }

        /// <summary>
        /// The retention policy to apply over and above max*msgs, max*bytes and max_age
        /// </summary>
        [Input("retention")]
        public Input<string>? Retention { get; set; }

        [Input("sources")]
        private InputList<Inputs.StreamSourceArgs>? _sources;

        /// <summary>
        /// The subject transform source
        /// </summary>
        public InputList<Inputs.StreamSourceArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.StreamSourceArgs>());
            set => _sources = value;
        }

        /// <summary>
        /// The storage engine to use to back the stream
        /// </summary>
        [Input("storage")]
        public Input<string>? Storage { get; set; }

        /// <summary>
        /// The subject filtering sources and associated destination transforms
        /// </summary>
        [Input("subjectTransform")]
        public Input<Inputs.StreamSubjectTransformArgs>? SubjectTransform { get; set; }

        [Input("subjects")]
        private InputList<string>? _subjects;

        /// <summary>
        /// The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        /// </summary>
        public InputList<string> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<string>());
            set => _subjects = value;
        }

        public StreamArgs()
        {
        }
        public static new StreamArgs Empty => new StreamArgs();
    }

    public sealed class StreamState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If the Stream should support confirming receiving messages via acknowledgements
        /// </summary>
        [Input("ack")]
        public Input<bool>? Ack { get; set; }

        /// <summary>
        /// Allow higher performance, direct access to get individual messages via the $JS.DS.GET API
        /// </summary>
        [Input("allowDirect")]
        public Input<bool>? AllowDirect { get; set; }

        /// <summary>
        /// Allows the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message
        /// </summary>
        [Input("allowRollupHdrs")]
        public Input<bool>? AllowRollupHdrs { get; set; }

        /// <summary>
        /// Optional compression algorithm used for the Stream
        /// </summary>
        [Input("compression")]
        public Input<string>? Compression { get; set; }

        /// <summary>
        /// Restricts the ability to delete messages from a stream via the API. Cannot be changed once set to true
        /// </summary>
        [Input("denyDelete")]
        public Input<bool>? DenyDelete { get; set; }

        /// <summary>
        /// Restricts the ability to purge messages from a stream via the API. Cannot be change once set to true
        /// </summary>
        [Input("denyPurge")]
        public Input<bool>? DenyPurge { get; set; }

        /// <summary>
        /// Contains additional information about this stream
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// When a Stream reach it's limits either old messages are deleted or new ones are denied
        /// </summary>
        [Input("discard")]
        public Input<string>? Discard { get; set; }

        /// <summary>
        /// When discard policy is new and the stream is one with max messages per subject set, this will apply the new behavior to every subject. Essentially turning discard new from maximum number of subjects into maximum number of messages in a subject
        /// </summary>
        [Input("discardNewPerSubject")]
        public Input<bool>? DiscardNewPerSubject { get; set; }

        /// <summary>
        /// The size of the duplicate tracking windows, duration specified in seconds
        /// </summary>
        [Input("duplicateWindow")]
        public Input<int>? DuplicateWindow { get; set; }

        /// <summary>
        /// The maximum oldest message that can be kept in the stream, duration specified in seconds
        /// </summary>
        [Input("maxAge")]
        public Input<int>? MaxAge { get; set; }

        /// <summary>
        /// The maximum size of all messages that can be kept in the stream
        /// </summary>
        [Input("maxBytes")]
        public Input<int>? MaxBytes { get; set; }

        /// <summary>
        /// Number of consumers this stream allows
        /// </summary>
        [Input("maxConsumers")]
        public Input<int>? MaxConsumers { get; set; }

        /// <summary>
        /// The maximum individual message size that the stream will accept
        /// </summary>
        [Input("maxMsgSize")]
        public Input<int>? MaxMsgSize { get; set; }

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream
        /// </summary>
        [Input("maxMsgs")]
        public Input<int>? MaxMsgs { get; set; }

        /// <summary>
        /// The maximum amount of messages that can be kept in the stream on a per-subject basis
        /// </summary>
        [Input("maxMsgsPerSubject")]
        public Input<int>? MaxMsgsPerSubject { get; set; }

        [Input("metadata")]
        private InputMap<string>? _metadata;

        /// <summary>
        /// Free form metadata about the stream
        /// </summary>
        public InputMap<string> Metadata
        {
            get => _metadata ?? (_metadata = new InputMap<string>());
            set => _metadata = value;
        }

        /// <summary>
        /// Specifies a remote stream to mirror into this one
        /// </summary>
        [Input("mirror")]
        public Input<Inputs.StreamMirrorGetArgs>? Mirror { get; set; }

        /// <summary>
        /// The name of the source Stream
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Place the stream in a specific cluster, influenced by placement_tags
        /// </summary>
        [Input("placementCluster")]
        public Input<string>? PlacementCluster { get; set; }

        [Input("placementTags")]
        private InputList<string>? _placementTags;

        /// <summary>
        /// Place the stream only on servers with these tags
        /// </summary>
        public InputList<string> PlacementTags
        {
            get => _placementTags ?? (_placementTags = new InputList<string>());
            set => _placementTags = value;
        }

        /// <summary>
        /// How many replicas of the data to keep in a clustered environment
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// The destination to publish messages to
        /// </summary>
        [Input("republishDestination")]
        public Input<string>? RepublishDestination { get; set; }

        /// <summary>
        /// Republish only message headers, no bodies
        /// </summary>
        [Input("republishHeadersOnly")]
        public Input<bool>? RepublishHeadersOnly { get; set; }

        /// <summary>
        /// Republish messages to republish_destination
        /// </summary>
        [Input("republishSource")]
        public Input<string>? RepublishSource { get; set; }

        /// <summary>
        /// The retention policy to apply over and above max*msgs, max*bytes and max_age
        /// </summary>
        [Input("retention")]
        public Input<string>? Retention { get; set; }

        [Input("sources")]
        private InputList<Inputs.StreamSourceGetArgs>? _sources;

        /// <summary>
        /// The subject transform source
        /// </summary>
        public InputList<Inputs.StreamSourceGetArgs> Sources
        {
            get => _sources ?? (_sources = new InputList<Inputs.StreamSourceGetArgs>());
            set => _sources = value;
        }

        /// <summary>
        /// The storage engine to use to back the stream
        /// </summary>
        [Input("storage")]
        public Input<string>? Storage { get; set; }

        /// <summary>
        /// The subject filtering sources and associated destination transforms
        /// </summary>
        [Input("subjectTransform")]
        public Input<Inputs.StreamSubjectTransformGetArgs>? SubjectTransform { get; set; }

        [Input("subjects")]
        private InputList<string>? _subjects;

        /// <summary>
        /// The list of subjects that will be consumed by the Stream, may be empty when sources and mirrors are present
        /// </summary>
        public InputList<string> Subjects
        {
            get => _subjects ?? (_subjects = new InputList<string>());
            set => _subjects = value;
        }

        public StreamState()
        {
        }
        public static new StreamState Empty => new StreamState();
    }
}
